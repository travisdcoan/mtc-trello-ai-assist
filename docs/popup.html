<!-- https://becurrent.mixtapeco.com/trello-powerup/popup.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Rename Suggestions</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --border: #e5e7eb;
      --btn-bg: #5c4949;
      --btn-text: #ffffff;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0f141a;
        --text: #f3f4f6;
        --muted: #a1a1aa;
        --border: #334155;
        --btn-bg: #4b3c3c;
        --btn-text: #f9fafb;
      }
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; background: var(--bg); color: var(--text); }
    body { font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; padding: 12px; }

    #advice {
      font-size: 14px;
      border-bottom-right-radius: 8px;
      border-top-right-radius: 8px;
      color: rgb(0, 35, 20);
      white-space: pre-wrap;
      background: #D3F1A7;
      border-left: 4px solid #6BB300;
      padding: 1rem;
      margin-bottom: 1.25rem;
      margin-top: -10px;
    }
    

    #message { margin: 0 0 8px 0; color: var(--muted); }
    #suggestions button {
      display: block; width: 100%;
      margin: 6px 0; padding: 8px 12px;
      font-size: 14px; text-align: left; cursor: pointer;
      border: 0; border-radius: 8px;
      background: rgba(9, 32, 70, 0.04); color: #172B4D;
      text-transform: none;
    }

    #cancel-btn {
      display: block;
      margin: 14px auto 0;
      background: none; border: none;
      color: var(--muted);
      text-decoration: underline;
      cursor: pointer; font-size: 13px;
    }

    #why-section { margin-top: 14px; padding-top: 12px; border-top: 1px solid var(--border); }
    #why-toggle {
      width: 100%; display: flex; align-items: center; justify-content: space-between; gap: 8px;
      background: none; border: 0; padding: 0; color: var(--muted); cursor: pointer; font: inherit; font-size: 13px;
    }
    #why-toggle:hover { color: var(--text); }
    #why-arrow { transition: transform .25s ease; }
    #why-content { margin-top: 8px; color: var(--muted); font-size: 12px; line-height: 1.55; display: none; }

    .hidden { display: none !important; }
    .small { font-size: 12px; color: var(--muted); }
  </style>
</head>
<body>
  <div id="advice" class="advice">Loading advice…</div>
  <p id="caption" class="small"></p>
  <div id="suggestions"></div>
  <button id="cancel" class="link">Not now</button>

  <!-- BeCurrent: Why we do this (self-contained) -->
  <div id="bc-why" style="margin-top:14px; padding-top:12px; border-top:1px solid var(--border, #e5e7eb);">
    <button id="bc-why-toggle" type="button"
            style="width:100%; display:flex; align-items:center; justify-content:space-between; gap:8px; cursor:pointer; background:none; border:0; padding:0; color:var(--muted, #6b7280); font:inherit; font-size:13px;">
      <span>Why we do this</span>
      <!-- Chevron -->
      <svg id="bc-why-arrow" xmlns="http://www.w3.org/2000/svg" width="16" height="16"
          viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round" style="transition:transform .25s ease;">
        <polyline points="6 9 12 15 18 9"></polyline>
      </svg>
    </button>

    <div id="bc-why-content"
        style="display:none; margin-top:8px; color:var(--muted, #6b7280); font-size:12px; line-height:1.55;">
      <p style="margin:0;">
        this naming prompt helps you turn ideas into action. starting with a verb makes each card clear,
        doable, and time-bound. it shifts your brain from thinking about work to moving into it — one small,
        concrete step at a time.
      </p>
    </div>
</div>

<script>
/* BeCurrent: isolated dropdown toggler (no globals, no collisions) */
(function(){
  var btn = document.getElementById('bc-why-toggle');
  var content = document.getElementById('bc-why-content');
  var arrow = document.getElementById('bc-why-arrow');
  if(!btn || !content) return;

  btn.addEventListener('click', function(e){
    e.preventDefault(); e.stopPropagation();
    var open = content.style.display !== 'none';
    content.style.display = open ? 'none' : 'block';
    if (arrow) arrow.style.transform = open ? 'rotate(0deg)' : 'rotate(180deg)';

    // Friendly resize for Trello popups (safe no-op elsewhere)
    try {
      var t = window.TrelloPowerUp && window.TrelloPowerUp.iframe ? window.TrelloPowerUp.iframe() : null;
      if (t && t.sizeTo) t.sizeTo(document.body);
    } catch (_) {}
  });
})();
</script>


  <script src="https://p.trellocdn.com/power-up.min.js"></script>
  <script>
    // ================== CONFIG ==================
    const APP_KEY   = "bc773ec2e45cf527b1ad22819fb7c71b";
    const AI_URL    = "https://askyeti.co/api/goal/be-current";
    const CACHE_KEY = "aiSuggest:v5"; // bump to invalidate old cache
    const FALLBACK  = ["Add","Create","Fix","Update","Review","Write","Organize","Plan"];

    // ---------- Trello REST auth helper ----------
    // Handles the "Token request rejected" bug and lets users re-auth cleanly.
    // IMPORTANT: Only call ensureUserToken() from inside a real click handler.

    async function getCleanToken(client) {
      let token = null;
      try {
        token = await client.getToken();
      } catch (_) {}

      // Trello stores this literal value when the user denies auth:
      // "&error=Token%20request%20rejected"
      if (
        token &&
        typeof token === "string" &&
        token.indexOf("error=Token%20request%20rejected") !== -1
      ) {
        try { await client.clearToken(); } catch (_) {}
        token = null;
      }

      return token;
    }

    async function ensureUserToken(client) {
      // 1) Check any existing token and clear the "denied" sentinel if present.
      let token = await getCleanToken(client);
      if (token) return token;

      // 2) Ask Trello for permission. This MUST run inside a click handler
      //    so the popup isn't blocked by the browser.
      try {
        await client.authorize({
          scope: "read,write",
          expiration: "never",
          callbackMethod: "postMessage",
          name: "BeCurrent",
        });
      } catch (e) {
        const deniedError =
          TrelloPowerUp &&
          TrelloPowerUp.restApiError &&
          TrelloPowerUp.restApiError.AuthDeniedError;

        if (e === deniedError || (e && e.name === "AuthDeniedError")) {
          // User explicitly cancelled / closed the window.
          // Return null so the caller can show a friendly message,
          // and let them click again later.
          return null;
        }
        throw e;
      }

      // 3) Read the token after authorization; clear "denied" tokens if any.
      token = await getCleanToken(client);
      return token || null;
    }


    // ================== TRELLO CONTEXT ==================
    const t = window.TrelloPowerUp.iframe({
      appKey:    APP_KEY,
      appName:   "Verb-Starter Checker",
      appAuthor: "Trav Coan"
    });

    // helper: close popup + card
    function closeAll() {
      try { t.hideCard(); } catch (_) {}
      try { t.closePopup(); } catch (_) {}
    }

    // ================== UTILS ==================
    const norm = s => String(s||"").trim().replace(/\s+/g," ").toLowerCase();
    const titleCase = s => String(s||"").replace(/\w\S*/g, w => w[0].toUpperCase()+w.slice(1));

    function stripCodeFences(s){
      return String(s||"").replace(/```[\s\S]*?```/g, "").trim();
    }
    function stripInlineJSON(s){
      // remove any lone {...} blocks that might appear at end
      return String(s||"").replace(/\{[\s\S]*\}\s*$/m, "").trim();
    }
    function extractJSONObject(s){
      if (!s) return null;
      // prefer ```json ... ```
      const fence = s.match(/```json\s*([\s\S]*?)```/i) || s.match(/```\s*([\s\S]*?)```/i);
      if (fence && fence[1]) { try { return JSON.parse(fence[1]); } catch {} }
      // fallback to first {...}
      const first = s.indexOf("{"), last = s.lastIndexOf("}");
      if (first !== -1 && last > first) {
        try { return JSON.parse(s.slice(first, last+1)); } catch {}
      }
      return null;
    }
    // Pull suggestions from messy free text like: suggestions:["a","b"] (handles smart quotes)
    function extractSuggestionsSoft(text){
      if (!text) return [];
      const s = String(text);
      const m = s.match(/suggestions\s*:\s*\[([\s\S]*?)\]/i);
      if (!m) return [];
      let inside = m[1].replace(/[“”]/g,'"').replace(/[‘’]/g,"'");
      const quoted = inside.match(/"([^"]+)"|'([^']+)'/g);
      if (quoted) return quoted.map(x => x.replace(/^['"]|['"]$/g,"").trim()).filter(Boolean);
      return inside.split(",").map(x => x.trim().replace(/^['"]|['"]$/g,"")).filter(Boolean);
    }

    function parseAI(raw){
      let message = "Try starting with a verb for more momentum.";
      let suggestions = [];

      if (raw && typeof raw === "object") {
        const msgRaw = String(raw.message || raw.response || "");
        message = stripInlineJSON(stripCodeFences(msgRaw)) || message;

        if (Array.isArray(raw.suggestions) && raw.suggestions.length) {
          suggestions = raw.suggestions.map(String);
        } else {
          const embedded = extractJSONObject(msgRaw);
          if (embedded && Array.isArray(embedded.suggestions) && embedded.suggestions.length) {
            suggestions = embedded.suggestions.map(String);
          } else {
            suggestions = extractSuggestionsSoft(msgRaw);
          }
        }
        return { message, suggestions };
      }

      const text = String(raw || "");
      message = stripInlineJSON(stripCodeFences(text)) || message;

      const obj = extractJSONObject(text);
      if (obj && Array.isArray(obj.suggestions) && obj.suggestions.length) {
        suggestions = obj.suggestions.map(String);
      } else {
        suggestions = extractSuggestionsSoft(text);
      }
      return { message, suggestions };
    }

    async function ensureAuth() {
      const client = t.getRestApi();
      if (!(await client.isAuthorized())) {
        await client.authorize({
          scope: { read: true, write: true },
          expiration: 'never',
          callbackMethod: 'postMessage'
        });
      }
      return { token: await client.getToken() };
    }

    async function fetchText(url, opts){
      const res = await fetch(url, opts);
      return {
        text: await res.text(),
        contentType: (res.headers.get("content-type") || "").toLowerCase()
      };
    }

    // Never-throw JSON parse
    const safeJSON = (s) => {
      if (s == null) return null;
      const r = String(s).replace(/^\uFEFF/, '').trim();
      if (!r || !/^[\[{]/.test(r)) return null;
      try { return JSON.parse(r); } catch { return null; }
    };

    // Get a valid Trello token *right before a write*, and prompt if needed
    async function getWriteToken(t) {
      const client = t.getRestApi();
      // Clear stale state if Trello "thinks" we're authed but token missing
      try { const tok = await client.getToken(); if (!tok) { try { await client.deauthorize(); } catch {} } }
      catch { try { await client.deauthorize(); } catch {} }

      if (!(await client.isAuthorized())) {
        await client.authorize({
          scope: 'read,write',          // MUST be a string
          expiration: 'never',
          callbackMethod: 'postMessage',
          name: 'BeCurrent'
        });
      }
      const token = await client.getToken();
      if (!token) throw new Error('No Trello token');
      return token;
    }

    // ================== DONE-LIST SUPPRESSION (no REST required) ==================
    async function isCardInDone() {
      const savedDone = await t.get("board","shared","doneList");
      const { idList } = await t.card("idList");       // from client context
      if (!idList) return false;

      if (savedDone?.id) return idList === savedDone.id;

      const { name } = await t.list("name");           // from client context
      const nm = (name || "").trim().toLowerCase();
      return nm === "done" || nm === "complete";
    }


    // ================== CACHE (lean) ==================
    async function readCache() { return t.get("card","shared", CACHE_KEY); }
    async function writeCache(payload) { return t.set("card","shared", CACHE_KEY, payload); }

    // Ignore cache if empty suggestions
    async function getAISuggestions(cardTitle){
      const normTitle = norm(cardTitle);
      const cached = await readCache();
      if (cached &&
          cached.titleNorm === normTitle &&
          Array.isArray(cached.suggestions) &&
          cached.suggestions.length > 0) {
        return { message: cached.messagePreview || "", suggestions: cached.suggestions };
      }

      let raw;
      try {
        const { text, contentType } = await fetchText(AI_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ message: cardTitle })
        });
        raw = contentType.includes("application/json") ? (safeJSON(text) ?? text) : text;
      } catch (e) {
        console.warn("[AI] fetch failed:", e);
      }

      const parsed = parseAI(raw);
      // Store tiny preview + suggestions only (avoid 4096 limit)
      const preview = String(parsed.message || "").slice(0, 700);
      await writeCache({
        titleNorm: normTitle,
        messagePreview: preview,
        suggestions: Array.isArray(parsed.suggestions) ? parsed.suggestions.slice(0, 12) : [],
        updatedAt: Date.now()
      });
      return parsed;
    }

    // ================== RENDER ==================
    t.render(async () => {
      try {
        const { id: cardId, name: cardName } = await t.card('id','name');
        if (!cardId || !cardName) throw new Error("Missing cardId or name from Trello context");


        // Suppress entirely on Done/Complete
        if (await isCardInDone()) {
          document.getElementById("advice").classList.add("hidden");
          document.getElementById("caption").textContent = "This card is in Done — suggestions are hidden.";
          document.getElementById("suggestions").innerHTML = "";
          t.sizeTo(document.body).catch(()=>{});
          return;
        }

        document.getElementById("caption").textContent = `Suggestions for “${cardName}”`;

        // Get AI (with cache guard)
        const { message, suggestions } = await getAISuggestions(cardName);

        // Show advice text ONLY (no code blocks / JSON)
        const adviceText = stripInlineJSON(stripCodeFences(message));
        const adviceEl = document.getElementById("advice");
        adviceEl.textContent = adviceText || "Here are some ideas to make this a one-sitting step.";

        // Build suggestion buttons (AI first; fallback if none)
        const out = document.getElementById("suggestions");
        out.innerHTML = "";
        const lower = (x) => String(x || "").toLowerCase().trim();
        const labels = (Array.isArray(suggestions) && suggestions.length)
          ? suggestions.map(lower)
          : FALLBACK.map(v => `${lower(v)} ${lower(cardName)}`);

        // Deduplicate + cap to 8
        const seen = new Set();
        const unique = [];
        for (const l of labels) {
          const k = norm(l);
          if (!seen.has(k)) { unique.push(l); seen.add(k); }
          if (unique.length >= 8) break;
        }

        // Rename on click
        for (const newName of unique) {
          const btn = document.createElement("button");
          btn.className = "btn";
          btn.textContent = newName;
          btn.addEventListener("click", async () => {
            try {
              const client = t.getRestApi();
              const token  = await ensureUserToken(client);

              if (!token) {
                // User cancelled or closed the Trello consent window.
                adviceEl.textContent =
                  'We need permission from Trello before we can rename cards. ' +
                  'Please click a suggestion again and choose “Allow” in the Trello window.';
                return;
              }

              const res = await fetch(
                `https://api.trello.com/1/cards/${cardId}?key=${APP_KEY}&token=${encodeURIComponent(token)}`,
                {
                  method: "PUT",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ name: newName }),
                }
              );

              if (res.status === 401) {
                // Token got revoked/expired; clear it so the next click re-opens the consent window.
                try { await client.clearToken(); } catch (_) {}
                adviceEl.textContent =
                  "Your Trello access seems to have expired. Click a suggestion again to re-authorize.";
                return;
              }

              if (!res.ok) {
                const body = await res.text().catch(() => "");
                throw new Error(
                  `[${res.status}] ${res.statusText || ""} ${body.slice(0, 200)}`
                );
              }

              await writeCache({
                titleNorm: norm(newName),
                messagePreview: "Looks good.",
                suggestions: [],
                updatedAt: Date.now(),
              });

              // close popup + card
              closeAll();
            } catch (e) {
              adviceEl.textContent = "Rename failed. Please try again.";
              console.error("[Popup] rename failed:", e);
            }
          });

          out.appendChild(btn);
        }

        // "Not now" closes popup + card
        document.getElementById("cancel").addEventListener("click", () => closeAll());
        t.sizeTo(document.body).catch(()=>{});
      } catch (err) {
        console.error("[Popup] render error:", err);
        document.body.innerHTML = `<p style="color:#b00020">An error occurred: ${String(err?.message || err)}</p>`;
        t.sizeTo(document.body).catch(()=>{});
      }
    });
  </script>
</body>
</html>
