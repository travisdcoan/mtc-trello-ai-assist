<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BeCurrent Next Steps</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --border: #e5e7eb;
      --btn-bg: #0f62fe;
      --btn-text: #ffffff;
      --link: #6b7280;
      --link-hover: #111827;
      --info-bg: #CFE2FF;
      --info-border: #025cea;
      --info-text: #123263;
      --danger: #b00020;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0f141a;
        --text: #f3f4f6;
        --muted: #a1a1aa;
        --border: #334155;
        --btn-bg: #3b82f6;
        --btn-text: #f9fafb;
        --link: #a1a1aa;
        --link-hover: #f3f4f6;
        --info-bg: #193655;
        --info-border: #7aa7ff;
        --info-text: #d7e6ff;
      }
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; background: var(--bg); color: var(--text); }
    body { font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; padding: 12px; }

    .row { margin-bottom: 10px; }
    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 4px; }
    input[type="text"], select {
      width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid var(--border);
      background: transparent; color: var(--text);
    }

    /* Info strip + lead paragraph */
    .desc {
      font-size: 14px;
      border-bottom-right-radius: 8px;
      border-top-right-radius: 8px;
      color: var(--info-text);
      background: var(--info-bg);
      border-left: 4px solid var(--info-border);
      padding: 1rem;
      margin-bottom: 0.5rem;
    }
    .lead { margin: 8px 0 14px; font-size: 14px; color: var(--text); }

    /* Buttons + archive link bottom-right */
    .btnbar {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 8px;
      margin-top: 12px;
    }
    .btnrow { display: flex; gap: 8px; }
    button.primary {
      background: var(--btn-bg); color: var(--btn-text);
      border: none; border-radius: 8px; padding: 8px 12px; cursor: pointer;
    }
    button.secondary {
      background: none; color: var(--muted); border: 1px solid var(--border);
      border-radius: 8px; padding: 8px 12px; cursor: pointer;
    }
    .archive-link {
      justify-self: end;
      font-size: 12px;
      color: var(--link);
      text-decoration: underline;
      background: none;
      border: 0;
      padding: 0;
      cursor: pointer;
    }
    .archive-link:hover { color: var(--link-hover); }

    .small { font-size: 12px; color: var(--muted); }
    .error { color: var(--danger); margin-top: 6px; }

    /* Why section */
    #why-section { margin-top: 14px; padding-top: 12px; border-top: 1px solid var(--border); }
    #why-toggle {
      width: 100%;
      display: flex; align-items: center; justify-content: space-between;
      gap: 8px;
      background: none; border: 0; padding: 0;
      color: var(--muted); cursor: pointer; font: inherit; font-size: 13px;
    }
    #why-toggle:hover { color: var(--text); }
    #why-arrow { transition: transform .25s ease; }
    #why-content { margin-top: 8px; color: var(--muted); font-size: 12px; line-height: 1.55; display: none; }

    /* Remove native arrow on the "Move to" dropdown */
    #destList {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: none;   /* in case the browser uses a background icon */
    }

    /* Old IE / Edge arrow */
    #destList::-ms-expand {
      display: none;
    }

  </style>
</head>
<body>
  <form id="form" style="margin-top: -30px;">
    <!-- Info strip text -->
    <p class="desc" data-role="prompt">
      Thinking about what's next helps build momentum. What's one small thing you can do to continue your progress?
    </p>
    <!-- Lead paragraph under the strip -->
    <p class="lead">Now that you've completed this, is there a next step that needs to happen??</p>

    <div class="row">
      <label for="newName">Rename (optional)</label>
      <input type="text" id="newName" autocomplete="off" />
    </div>

    <div class="row">
      <label for="destList">Move to</label>
      <select id="destList"></select>
    </div>

    <div class="btnbar">
      <div class="btnrow">
        <button type="submit" class="primary">Apply</button>
        <button type="button" id="cancel" class="secondary">Cancel</button>
      </div>
      <!-- Bottom-right archive link (outside dropdown) -->
      <button type="button" id="archiveLink" class="archive-link">Archive it</button>
    </div>

    <div id="error" class="error" hidden></div>

    <!-- Why we do this (at bottom) -->
    <div id="why-section" aria-live="polite">
      <button type="button" id="why-toggle" aria-expanded="false" aria-controls="why-content">
        <span>Why we do this</span>
        <svg id="why-arrow" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <polyline points="6 9 12 15 18 9"></polyline>
        </svg>
      </button>
      <div id="why-content">
        <p>
          this done-card prompt nudges you to capture a tiny follow-up, rename it for clarity if helpful,
          and send it where it belongs—or archive to keep things tidy. it’s about turning completion into
          momentum with as little friction as possible.
        </p>
      </div>
    </div>
  </form>

  <script src="https://p.trellocdn.com/power-up.min.js"></script>
  <script>
    const DONE_PROMPTS = [
      "Before we close the loop, take a breath—anything still lingering? A tiny next step hiding in the wings?",
      "This one’s off your plate—beautifully done. Pause for a beat: is anything else asking for your attention?",
      "The completion of one card can reveal what’s next. Any threads to tie up?",
      "Your part is done—but is it truly wrapped? Is someone else still holding a piece? Any baton to pass? Anyone to inform or thank?",
      "Funny how the brain works: we often remember something right after we mark it done. Anything bubbling up now?",
      "You’ve crossed your finish line—well done. Just double-check: no follow-ups, handoffs, or quiet “oh wait”s?",
      "Marking it done feels good. This quick check makes sure “done” doesn’t leave anything behind.",
      "Is this just done—or did completing it unlock something new? Anything to capture before we move on?",
      "Great job seeing this through! Sometimes finishing one thing stirs the next. Any ripples to follow?",
      "You did what you set out to do. Quick gut check: is it fully complete, or is there one last tiny thing?",
      "You did it. Take a moment—breathe it in, smile, even do a little dance. Completion deserves to be felt.",
      "Now that this card is done, what might be ready to emerge? Anything whispering, “I’m next”?"
    ];
    function pickPromptRandom() {
      return DONE_PROMPTS[Math.floor(Math.random() * DONE_PROMPTS.length)];
    }
    function pickPromptStable(cardId) {
      let h = 5381; for (let i=0;i<cardId.length;i++) h=((h<<5)+h)^cardId.charCodeAt(i);
      return DONE_PROMPTS[Math.abs(h) % DONE_PROMPTS.length];
    }
    async function setDonePrompt(t, { stable = false } = {}) {
      const el = document.getElementById("advice")
            || document.querySelector(".advice")
            || document.querySelector('[data-role="prompt"]');
      if (!el) return;
      let text = pickPromptRandom();
      if (stable) {
        try { const { id } = await t.card('id'); text = pickPromptStable(id||""); } catch {}
      }
      el.textContent = text;
    }
  </script>

  <script>
    // Load shared config (cache-busted by the same ?v=... as the iframe)
    (function(){
      try {
        var v = new URLSearchParams(location.search).get('v');
        var src = 'js/bc-config.js' + (v ? ('?v=' + encodeURIComponent(v)) : '');
        document.write('<script src="' + src + '"><\\/script>');
      } catch (_) {
        document.write('<script src="js/bc-config.js"><\\/script>');
      }
    })();

    const CFG = (window.BC_CONFIG || {});
    const APP_KEY = CFG.APP_KEY || (Array.isArray(CFG.APP_KEYS) ? CFG.APP_KEYS[0] : "");

    const t = window.TrelloPowerUp.iframe({
      appKey:    APP_KEY,
      appName:   CFG.APP_NAME || "BeCurrent",
      appAuthor: CFG.APP_AUTHOR || "Trav Coan"
    });

    // helper: close popup + card
    function closeAll() {
      try { t.hideCard(); } catch (_) {}
      try { t.closePopup(); } catch (_) {}
    }

    function showError(msg) {
      const el = document.getElementById("error");
      el.textContent = msg || "";
      el.hidden = !msg;
    }

    // ----- Auth helpers (fix the “stuck” deny state) -----
    async function getCleanToken(client) {
      let token = null;
      try {
        token = await client.getToken();
      } catch (_) {}

      // When the user denies auth, Trello can stash an error string here.
      if (
        token &&
        typeof token === "string" &&
        token.indexOf("error=Token%20request%20rejected") !== -1
      ) {
        try { await client.clearToken(); } catch (_) {}
        token = null;
      }

      return token;
    }

    async function ensureUserToken(client) {
      // 1) See if we already have a good token (and clear the "denied" sentinel if present).
      let token = await getCleanToken(client);
      if (token) return token;

      // 2) No good token — ask for permission (must be called from a click/submit).
      try {
        await client.authorize({
          scope: "read,write",
          expiration: "never",
          callbackMethod: "postMessage",
          name: "BeCurrent",
        });
      } catch (e) {
        const tp = window.TrelloPowerUp;
        const deniedError = tp && tp.restApiError && tp.restApiError.AuthDeniedError;

        const isDenied =
          e === deniedError ||
          (e && e.name === "AuthDeniedError") ||
          (typeof e === "string" &&
            e.toLowerCase().includes("auth") &&
            e.toLowerCase().includes("denied")) ||
          (e && typeof e.message === "string" &&
            e.message.toLowerCase().includes("auth") &&
            e.message.toLowerCase().includes("denied"));

        if (isDenied) {
          // User closed / denied the Trello popup.
          // Don't throw—callers will see `null` and just show a friendly message.
          return null;
        }

        console.error("[next-steps] unexpected auth error:", e);
        throw e;
      }

      // 3) Re-read token after auth, clear any weird error state.
      token = await getCleanToken(client);
      return token || null;
    }

    t.render(async () => {
      try {
        const { id: cardId, name, idList: currentListId } =
          await t.card("id", "name", "idList");
        if (!cardId) throw new Error("Missing cardId from context");

        await setDonePrompt(t, { stable: false });

        const nameInput = document.getElementById("newName");
        const sel = document.getElementById("destList");
        nameInput.value = name;

        // Load board lists via the Power-Up client (no REST auth needed)
        const allLists = await t.lists("all"); // [{ id, name, closed }, ...]
        // Trello returns these in board order (left → right)
        const lists = allLists.filter((l) => !l.closed);

        // Decide what should be selected by default.
        // Card is already in Done; we prefer the list immediately to the left of it.
        let defaultListId = currentListId;
        const currentIndex = lists.findIndex((l) => l.id === currentListId);

        if (currentIndex > 0) {
          // Use the column to the LEFT of Done
          defaultListId = lists[currentIndex - 1].id;
        } else if (lists.length) {
          // Fallback: first list if we can't find the current one for some reason
          defaultListId = lists[0].id;
        }

        // Build dropdown
        sel.innerHTML = "";
        for (const list of lists) {
          const opt = document.createElement("option");
          opt.value = list.id;
          opt.textContent = list.name;

          if (list.id === defaultListId) {
            opt.selected = true;
          }

          sel.appendChild(opt);
        }


        // Submit handler
        document.getElementById("form").addEventListener("submit", async (e) => {
          e.preventDefault();
          showError("");

          const newName = nameInput.value.trim();
          const choice  = sel.value;

          // If nothing changed, just close card + popup.
          if ((!newName || newName === name) && (!choice || choice === currentListId)) {
            closeAll();
            return;
          }

          try {
            const client = t.getRestApi();
            let token = await ensureUserToken(client);

            if (!token) {
              showError(
                'We need permission from Trello before we can rename or move cards. ' +
                'Click Apply again and choose “Allow” in the Trello window.'
              );
              return;
            }

            const url = `https://api.trello.com/1/cards/${cardId}?key=${APP_KEY}&token=${encodeURIComponent(
              token
            )}`;

            // Rename if changed
            if (newName && newName !== name) {
              let res = await fetch(url, {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ name: newName }),
              });

              if (res.status === 401) {
                try { await client.clearToken(); } catch (_) {}
                showError(
                  "Your Trello access seems to have expired. Click Apply again to re-authorize."
                );
                return;
              }
              if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
            }

            // Move if a different list was chosen
            if (choice && choice !== currentListId) {
              let res = await fetch(url, {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ idList: choice }),
              });

              if (res.status === 401) {
                try { await client.clearToken(); } catch (_) {}
                showError(
                  "Your Trello access seems to have expired. Click Apply again to re-authorize."
                );
                return;
              }
              if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
            }

            // close popup + card after success
            closeAll();
          } catch (err) {
            console.error("[Next-steps] apply failed:", err);
            showError("Something went wrong. Please try again.");
          }
        });

        // Archive link handler (bottom right)
        document.getElementById("archiveLink").addEventListener("click", async (e) => {
          e.preventDefault();
          e.stopPropagation();
          showError("");

          try {
            const client = t.getRestApi();
            let token = await ensureUserToken(client);

            if (!token) {
              showError(
                'We need permission from Trello before we can archive cards. ' +
                'Click “Archive it” again and choose “Allow” in the Trello window.'
              );
              return;
            }

            const res = await fetch(
              `https://api.trello.com/1/cards/${cardId}?key=${APP_KEY}&token=${encodeURIComponent(
                token
              )}`,
              {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ closed: true }),
              }
            );

            if (res.status === 401) {
              try { await client.clearToken(); } catch (_) {}
              showError(
                "Your Trello access seems to have expired. Click “Archive it” again to re-authorize."
              );
              return;
            }

            if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);

            // archive succeeded – close popup + card
            closeAll();
          } catch (err) {
            console.error("[Next-steps] archive failed:", err);
            showError("Archiving failed. Please try again.");
          }
        });

        // Cancel → close card
        document.getElementById("cancel").addEventListener("click", () => closeAll());

        // Why toggle + auto-resize
        const whyToggle = document.getElementById("why-toggle");
        const whyContent = document.getElementById("why-content");
        const whyArrow = document.getElementById("why-arrow");
        whyToggle.addEventListener("click", (e) => {
          e.preventDefault(); e.stopPropagation();
          const expanded = whyToggle.getAttribute("aria-expanded") === "true";
          whyToggle.setAttribute("aria-expanded", String(!expanded));
          whyContent.style.display = expanded ? "none" : "block";
          whyArrow.style.transform = expanded ? "rotate(0deg)" : "rotate(180deg)";
          t.sizeTo(document.body).catch(()=>{});
        });

        t.sizeTo(document.body).catch(()=>{});
      } catch (err) {
        console.error("[Next-steps] render error:", err);
        showError(err?.message || String(err));
        t.sizeTo(document.body).catch(()=>{});
      }
    });
  </script>
</body>
</html>
